<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>404Vision - 3D Audio Visualizer</title>
    <link href="https://fonts.googleapis.com/css2?family=Sora:wght@300;400;500;600;700&display=swap" rel="stylesheet">
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            color: #fff !important;
        }

        body {
            margin: 0;
            padding: 0;
            background: #000; /* fallback for no video, but will be visible only if no video is loaded */
            font-family: 'Sora', sans-serif;
            font-weight: 300;
            overflow: hidden;
        }

        /* Opening Page Styles */
        #openingPage {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 1000;
            transition: opacity 0.8s ease, visibility 0.8s ease;
            background: #000 !important;
        }

        #openingPage.hidden {
            opacity: 0;
            visibility: hidden;
        }

        .title {
            font-size: clamp(4rem, 12vw, 12rem);
            font-weight: 900;
            letter-spacing: -0.15em;
            margin-bottom: 2rem;
            text-align: center;
            color: #fff !important;
            animation: shimmer 3s ease-in-out infinite;
            text-shadow: none !important;
        }

        .title-404 {
            font-family: 'Times New Roman', serif;
            font-size: clamp(4.5rem, 13vw, 13rem);
            font-weight: 900;
        }

        .title-vision {
            font-family: 'Sora', sans-serif;
            font-size: clamp(4rem, 12vw, 12rem);
            font-weight: 900;
            letter-spacing: -0.04em;
        }

        @keyframes shimmer {
            0%, 100% { background-position: 0% 50%; }
            50% { background-position: 100% 50%; }
        }

        .subtitle {
            font-size: clamp(1rem, 3vw, 1.5rem);
            font-weight: 400;
            color: #888;
            margin-bottom: 3rem;
            text-align: center;
            letter-spacing: 0.1em;
        }

        .start-button {
            padding: 1rem 2rem;
            background: transparent !important;
            color: transparent !important;
            border: 2px solid #fff;
            border-radius: 50px;
            font-family: 'Sora', sans-serif;
            font-weight: 500;
            font-size: 1rem;
            cursor: pointer;
            transition: all 0.3s ease;
            letter-spacing: 0.1em;
        }

        .start-button:hover {
            background: transparent !important;
            color: transparent !important;
            border: 2px solid #fff;
            transform: translateY(-2px);
            box-shadow: 0 10px 30px rgba(0,0,0,0.12);
        }

        /* Main Container */
        #container {
            position: relative;
            width: 100vw;
            height: 100vh;
        }

        /* UI Scale Wrapper */
        #uiWrapper {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            transform: scale(0.975);
            transform-origin: top left;
            z-index: 100;
            pointer-events: none;
        }

        #uiWrapper * {
            pointer-events: auto;
        }

        /* Drop Zone */
        #dropZone {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0,0,0,0.9);
            border: 3px dashed #666;
            border-radius: 20px;
            display: none;
            justify-content: center;
            align-items: center;
            z-index: 500;
            font-size: 1.5rem;
            color: #ccc;
            font-weight: 500;
        }

        #dropZone.active {
            display: flex;
            border-color: #fff;
            color: #fff;
        }

        /* Adjust for scaled UI */
        #controls {
            position: absolute;
            top: 20px;
            left: 20px;
            z-index: 100;
            padding: 20px;
            border-radius: 15px;
            transition: all 0.3s ease;
            backdrop-filter: blur(10px);
            min-width: 300px;
        }

        #controls.hidden {
            opacity: 0;
            pointer-events: none;
            transform: translateY(-20px);
        }

        .control-group {
            margin-bottom: 15px;
        }

        .control-group:last-child {
            margin-bottom: 0;
        }

        .control-label {
            display: block;
            font-size: 0.8rem;
            color: #aaa;
            margin-bottom: 5px;
            font-weight: 500;
            letter-spacing: 0.05em;
        }

        #fileInput {
            width: 100%;
            padding: 10px;
            background: #222;
            color: white;
            border-radius: 8px;
            font-family: 'Sora', sans-serif;
            font-size: 0.9rem;
        }

        .button-group {
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
        }

        .btn {
            padding: 8px 16px;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            font-family: 'Sora', sans-serif;
            font-weight: 500;
            font-size: 0.9rem;
            transition: all 0.2s ease;
            flex: 1;
            min-width: 80px;
        }

        .btn-primary,
        #playButton,
        #progressPlayPause {
            color: #000 !important;
        }

        #progressPlayPause {
            background: transparent !important;
        }

        .btn-primary:hover {
            background: #ddd;
            transform: translateY(-1px);
        }

        .btn-secondary {
            background: #333;
            color: #fff;
        }

        .btn-secondary:hover {
            background: #555;
            transform: translateY(-1px);
        }

        .close-btn {
            position: absolute;
            top: 10px;
            right: 10px;
            width: 30px;
            height: 30px;
            background: none;
            border: none;
            color: #666;
            font-size: 20px;
            cursor: pointer;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.2s ease;
        }

        .close-btn:hover {
            background: #333;
            color: #fff;
        }

        /* Progress and Volume Controls */
        .slider {
            width: 100%;
            height: 4px;
            border-radius: 2px;
            background: #333;
            outline: none;
            appearance: none;
            -webkit-appearance: none;
        }

        .slider::-webkit-slider-thumb {
            appearance: none;
            -webkit-appearance: none;
            width: 16px;
            height: 16px;
            border-radius: 50%;
            background: #fff;
            cursor: pointer;
            border: 2px solid #000;
        }

        .slider::-moz-range-thumb {
            width: 16px;
            height: 16px;
            border-radius: 50%;
            background: #fff;
            cursor: pointer;
            border: 2px solid #000;
        }

        #progressContainer {
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .time-display {
            font-size: 0.8rem;
            color: #aaa;
            min-width: 40px;
            font-weight: 400;
        }

        /* Track Info */
        #trackInfo {
            position: absolute;
            bottom: 20px;
            left: 20px;
            z-index: 100;
            padding: 15px 20px;
            border-radius: 15px;
            max-width: 400px;
            transition: all 0.3s ease;
            backdrop-filter: blur(10px);
        }

        #trackInfo.hidden {
            opacity: 0;
            pointer-events: none;
            transform: translateY(20px);
        }

        .track-title {
            font-size: 1.1rem;
            font-weight: 600;
            margin-bottom: 5px;
            color: #fff;
        }

        .track-details {
            font-size: 0.8rem;
            color: #aaa;
            line-height: 1.4;
        }

        /* Info Panel */
        #info {
            position: absolute;
            bottom: 15px;
            right: 15px;
            z-index: 100;
            padding: 15px;
            border-radius: 15px;
            font-size: 0.8rem;
            color: #ccc;
            transition: all 0.3s ease;
            backdrop-filter: blur(10px);
        }

        #info.hidden {
            opacity: 0;
            pointer-events: none;
            transform: translateY(20px);
        }

        /* Frequency Info */
        #frequencyInfo {
            position: absolute;
            top: 15px;
            right: 15px;
            z-index: 100;
            padding: 15px;
            border-radius: 15px;
            font-size: 0.8rem;
            color: #ccc;
            transition: all 0.3s ease;
            backdrop-filter: blur(10px);
        }

        #frequencyInfo.hidden {
            opacity: 0;
            pointer-events: none;
            transform: translateY(-20px);
        }

        .freq-indicator {
            margin: 8px 0;
            display: flex;
            align-items: center;
        }

        .freq-color {
            width: 20px;
            height: 15px;
            margin-right: 10px;
            border-radius: 3px;
        }

        /* Responsive Design */
        @media (max-width: 768px) {
            #uiWrapper {
                transform: scale(0.8);
            }
            
            #controls {
                position: fixed;
                top: 10px;
                left: 10px;
                right: 10px;
                min-width: auto;
                max-width: none;
            }

            #frequencyInfo {
                display: none;
            }

            #trackInfo {
                bottom: 10px;
                left: 10px;
                right: 10px;
                max-width: none;
            }

            #info {
                bottom: 10px;
                right: 10px;
                left: auto;
                font-size: 0.7rem;
            }

            .button-group {
                flex-direction: column;
            }

            .btn {
                min-width: auto;
            }
        }

        /* Loading Animation */
        .loading {
            display: inline-block;
            width: 20px;
            height: 20px;
            border: 2px solid #333;
            border-radius: 50%;
            border-top-color: #fff;
            animation: spin 1s ease-in-out infinite;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        /* Add custom switch styles */
        .switch {
            position: relative;
            display: inline-block;
            width: 38px;
            height: 22px;
            vertical-align: middle;
            margin-right: 8px;
        }
        .switch input {
            opacity: 0;
            width: 0;
            height: 0;
        }
        .slider-switch {
            position: absolute;
            cursor: pointer;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-color: #333;
            transition: .3s;
            border-radius: 22px;
        }
        .slider-switch:before {
            position: absolute;
            content: "";
            height: 16px;
            width: 16px;
            left: 3px;
            bottom: 2.5px;
            background-color: #fff;
            transition: .3s;
            border-radius: 50%;
            box-shadow: 0 1px 4px rgba(0,0,0,0.2);
        }
        input:checked + .slider-switch {
            background-color: #fff;
        }
        input:checked + .slider-switch:before {
            transform: translateX(16px);
            background-color: #222;
        }

        /* Add glossy, transparent, white style for waveform and timestamp */
        #waveformCanvas {
            background: linear-gradient(135deg, rgba(255,255,255,0.13) 0%, rgba(255,255,255,0.04) 100%);
            border-radius: 10px;
            box-shadow: 0 2px 12px 0 rgba(255,255,255,0.10), 0 1.5px 8px 0 rgba(255,255,255,0.08) inset;
            border: none;
            transition: box-shadow 0.2s;
        }
        #waveformCanvas::after {
            content: '';
            display: block;
            position: absolute;
            top: 0; left: 0; right: 0;
            height: 8px;
            background: linear-gradient(90deg, rgba(255,255,255,0.22) 0%, rgba(255,255,255,0.04) 100%);
            border-top-left-radius: 10px;
            border-top-right-radius: 10px;
            pointer-events: none;
            z-index: 2;
        }
        #liveTimestamp {
            margin-left: 4px;
            font-size: 1.05em;
            color: #fff;
            min-width: 48px;
            text-align: right;
            letter-spacing: 0.04em;
            font-family: 'Sora', sans-serif;
            background: none;
            border-radius: 0;
            padding: 0;
            box-shadow: none;
            backdrop-filter: none;
        }

        /* 404 Numbers */
        #numbers404 {
            position: fixed;
            top: 15px;
            right: 15px;
            font-family: 'Times New Roman', serif;
            font-size: 1.5rem;
            font-weight: bold;
            color: #fff;
            z-index: 100;
            transition: opacity 0.3s ease, visibility 0.3s ease;
            pointer-events: none;
            image-rendering: pixelated;
            image-rendering: -moz-crisp-edges;
            image-rendering: crisp-edges;
            filter: contrast(1.2) brightness(1.1);
        }

        #numbers404.hidden {
            opacity: 0;
            visibility: hidden;
        }

        #openingPage * {
            color: #fff !important;
            text-shadow: none !important;
        }

        /* Move upload boxes down 3px */
        #controls > .control-group:first-of-type {
            margin-top: 3px;
        }

        .popup-stack-img {
            position: absolute;
            left: 50%;
            top: 50%;
            width: 396px;
            height: auto;
            transform: translate(-50%, -50%) scale(1);
            opacity: 1;
            transition: opacity 0.3s, transform 0.3s;
            box-shadow: 0 8px 32px rgba(0,0,0,0.18);
            border-radius: 8px;
            background: #fff;
            filter: brightness(22.5);
        }
    </style>
</head>
<body>
    <!-- Opening Page -->
    <div id="openingPage">
        <h1 class="title">
            <span class="title-404">404</span>
            <span class="title-vision">VISION</span>
        </h1>
        <p class="subtitle">3D Audio Network Visualizer</p>
        <button class="start-button" onclick="enterApp()">ENTER</button>
    </div>

    <!-- Drop Zone -->
    <div id="dropZone">
        <div>
            <div style="font-size: 3rem; margin-bottom: 1rem;">🎵</div>
            <div>Drop your audio file here</div>
        </div>
    </div>

    <div id="container">
        <video id="backgroundVideo" style="position:fixed;top:0;left:0;width:100vw;height:100vh;object-fit:cover;z-index:1;display:none;pointer-events:none;opacity:0.804;" loop muted></video>
        <img id="backgroundGif" style="position:fixed;top:0;left:0;width:100vw;height:100vh;object-fit:cover;z-index:1;display:none;pointer-events:none;opacity:0.804;" />
        
        <!-- UI Wrapper for 75% scaling -->
        <div id="uiWrapper">
            <div id="controls" class="hidden">
                <button class="close-btn" onclick="toggleControls()">&times;</button>
                
                <!-- Move upload boxes here, above the button group -->
                <div class="control-group" style="display: flex; gap: 10px; justify-content: center; margin: 5px auto 18px auto;">
                    <div id="audioDropBox" style="flex: none; width: 200px; height: 67px; background:rgba(255,255,255,0.07); border-radius:8px; border:2px dashed rgba(255,255,255,0.3); display:flex; flex-direction:column; align-items:center; justify-content:center; cursor:pointer; transition:background 0.2s, border-color 0.2s; position:relative;" tabindex="0">
                        <div style="display:flex; align-items:center; justify-content:center; width:100%; height:27px; pointer-events:none;">
                            <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M12 16v-8"/><path d="M8 12l4-4 4 4"/><rect x="4" y="20" width="16" height="2" rx="1"/><rect x="2" y="4" width="20" height="16" rx="4"/></svg>
                        </div>
                        <div style="font-size:0.71em; color:#fff; font-weight:500; margin:4px 0 0 0; text-align:center; pointer-events:none;">Audio</div>
                        <div style="font-size:0.56em; color:#ccc; text-align:center; pointer-events:none;">Drop or click</div>
                        <input type="file" id="fileInput" accept="audio/*" style="display:none;">
                    </div>
                    <div id="videoDropBox" style="flex: none; width: 200px; height: 67px; background:rgba(255,255,255,0.07); border-radius:8px; border:2px dashed rgba(255,255,255,0.3); display:flex; flex-direction:column; align-items:center; justify-content:center; cursor:pointer; transition:background 0.2s, border-color 0.2s; position:relative;" tabindex="0">
                        <div style="display:flex; align-items:center; justify-content:center; width:100%; height:27px; pointer-events:none;">
                            <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M12 16v-8"/><path d="M8 12l4-4 4 4"/><rect x="4" y="20" width="16" height="2" rx="1"/><rect x="2" y="4" width="20" height="16" rx="4"/></svg>
                        </div>
                        <div style="font-size:0.71em; color:#fff; font-weight:500; margin:4px 0 0 0; text-align:center; pointer-events:none;">Video/GIF</div>
                        <div style="font-size:0.56em; color:#ccc; text-align:center; pointer-events:none;">Drop or click</div>
                        <input type="file" id="videoInput" accept="video/*,image/gif" style="display:none;">
                    </div>
                </div>

                <div class="control-group">
                    <div class="button-group">
                        <button id="playButton" class="btn btn-primary">PLAY</button>
                        <button id="fullscreenButton" class="btn btn-secondary">FULLSCREEN</button>
                    </div>
                </div>

                <div class="control-group">
                    <label class="control-label">VOLUME</label>
                    <div style="display: flex; align-items: center; gap: 10px;">
                        <input type="range" id="volumeSlider" class="slider" min="0" max="100" value="50">
                        <span id="volumePercent" style="min-width: 32px; text-align: right; font-size: 0.9rem;">50%</span>
                    </div>
                </div>

                <div class="control-group">
                    <label class="control-label">PLAYBACK SPEED</label>
                    <input type="range" id="speedSlider" class="slider" min="0.5" max="2" step="0.1" value="1">
                    <div style="text-align: center; font-size: 0.8rem; color: #aaa; margin-top: 5px;">
                        <span id="speedDisplay">1.0x</span>
                    </div>
                </div>

                <div class="control-group">
                    <label class="control-label">PROGRESS</label>
                    <div id="progressContainer" style="display: flex; align-items: center; gap: 10px;">
                        <span class="time-display" id="currentTime">0:00</span>
                        <input type="range" id="progressSlider" class="slider" min="0" max="100" value="0" style="flex: 1;">
                        <span class="time-display" id="totalTime">0:00</span>
                        <button id="progressPlayPause" class="btn btn-secondary" style="width: 28px; height: 28px; min-width: 28px; min-height: 28px; max-width: 28px; max-height: 28px; margin-left: 6px; padding: 0; display: flex; align-items: center; justify-content: center;">
                            <span id="progressPlayPauseIcon">
                                <svg width="16" height="16" viewBox="0 0 16 16" fill="currentColor" xmlns="http://www.w3.org/2000/svg" style="display: block;"><polygon points="4,2 13,8 4,14"/></svg>
                            </span>
                        </button>
                    </div>
                </div>

                <div class="control-group">
                    <label class="control-label" for="grainToggle">GRAIN ON BASS</label>
                    <label class="switch">
                        <input type="checkbox" id="grainToggle">
                        <span class="slider-switch"></span>
                    </label>
                    <span style="font-size: 0.9rem; color: #aaa;">Enable Grain</span>
                </div>

                <div style="margin-top: 15px; font-size: 0.7rem; color: #666; text-align: left;">
                    Press H to toggle UI • Drag to rotate • Scroll to zoom • Press G to toggle grain </div>
            </div>

            <div id="trackInfo" class="hidden">
                <div class="track-title" id="trackTitle">No track loaded</div>
                <div style="display: flex; flex-direction: row; align-items: center; justify-content: space-between; gap: 24px;">
                    <div class="track-details" style="min-width: 120px;">
                        <div>Duration: <span id="trackDuration">--:--</span></div>
                        <div>Size: <span id="trackSize">-- MB</span></div>
                    </div>
                    <div id="waveformRow" style="display: flex; align-items: center;">
                        <canvas id="waveformCanvas" width="180" height="36" style="height:36px;width:180px;background:rgba(255,255,255,0.07);border-radius:8px;"></canvas>
                        <span id="liveTimestamp" style="margin-left: 4px; font-size: 1.05em; color: #bff; min-width: 48px; text-align: right; letter-spacing: 0.04em; font-family: 'Manrope', sans-serif;">0:00</span>
                    </div>
                </div>
            </div>

            <div id="info" class="hidden">
                <div>Instagram: @ajayrmmesh</div>
                <div style="margin-top: 5px; font-size: 0.7rem; opacity: 0.7;">
                    Drag & drop audio files supported
                </div>
            </div>

            <div id="frequencyInfo" class="hidden">
                <!-- ... existing frequency info ... -->
            </div>

            <div id="numbers404" class="hidden">404NotFound</div>
        </div>
    </div>

    <div id="grainOverlay"></div>

    <div id="popupStackContainer" style="pointer-events:none; position:fixed; top:0; left:0; width:100vw; height:100vh; z-index:2000; display:none;"></div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
        let scene, camera, renderer, audioContext, analyser, dataArray;
        let boxes = [];
        let connections = [];
        let networkGroup;
        let audioElement, audioSource;
        let isPlaying = false;
        let mouseX = 0, mouseY = 0;
        let targetRotationX = 0, targetRotationY = 0;
        let currentRotationX = 0, currentRotationY = 0;
        let controlsVisible = true;
        let isAppStarted = false;
        let grainEnabled = false;
        let grainActive = false;
        let grainCanvas, grainCtx;
        let lastGrainResize = { w: 0, h: 0 };
        let waveformCanvas = document.getElementById('waveformCanvas');
        let waveformCtx = waveformCanvas ? waveformCanvas.getContext('2d') : null;
        let backgroundVideo = document.getElementById('backgroundVideo');
        let backgroundGif = document.getElementById('backgroundGif');

        // Enter the main application
        function enterApp() {
            // Instantly hide the opening page (no fade)
            document.getElementById('openingPage').style.display = 'none';
            // Show popup stack filling the screen
            const popupContainer = document.getElementById('popupStackContainer');
            popupContainer.innerHTML = '';
            popupContainer.style.display = 'block';
            const imgWidth = 330;
            const imgHeight = 156; // approximate for your image
            const vw = window.innerWidth;
            const vh = window.innerHeight;
            const numImages = 30;
            let shown = 0;
            function showNext() {
                if (shown >= numImages) {
                    popupContainer.style.display = 'none';
                    isAppStarted = true;
                    document.getElementById('controls').classList.remove('hidden');
                    document.getElementById('info').classList.remove('hidden');
                    document.getElementById('frequencyInfo').classList.remove('hidden');
                    document.getElementById('numbers404').classList.remove('hidden');
                    initThreeJS();
                    setupEventListeners();
                    createGrainOverlay();
                    return;
                }
                const img = document.createElement('img');
                img.src = '404error_popup2.jpg';
                img.className = 'popup-stack-img';
                img.style.zIndex = 2000 + shown;
                // Random position within viewport
                const left = Math.random() * (vw - imgWidth);
                const top = Math.random() * (vh - imgHeight);
                img.style.left = left + 'px';
                img.style.top = top + 'px';
                img.style.opacity = '1';
                img.style.transform = 'none';
                img.style.filter = 'none';
                popupContainer.appendChild(img);
                shown++;
                setTimeout(showNext, 30);
            }
            showNext();
        }

        // Initialize Three.js scene
        function initThreeJS() {
            scene = new THREE.Scene();
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setClearColor(0x000000, 0); // transparent
            renderer.domElement.style.position = 'fixed';
            renderer.domElement.style.top = '0';
            renderer.domElement.style.left = '0';
            renderer.domElement.style.width = '100vw';
            renderer.domElement.style.height = '100vh';
            renderer.domElement.style.zIndex = '2';
            document.getElementById('container').appendChild(renderer.domElement);

            camera.position.z = 120;
            createBoxNetwork();
            setupMouseControls();
            animate();
        }

        function createBoxNetwork() {
            networkGroup = new THREE.Group();
            networkGroup.position.set(0, 0, 0); // Ensure it's at the center
            
            const gridSize = 6;
            const spacing = 12;
            const offset = (gridSize - 1) * spacing / 2;

            for (let x = 0; x < gridSize; x++) {
                for (let y = 0; y < gridSize; y++) {
                    for (let z = 0; z < gridSize; z++) {
                        let frequencyBand;
                        if (z < gridSize / 3) {
                            frequencyBand = 'bass';
                        } else if (z < 2 * gridSize / 3) {
                            frequencyBand = 'mid';
                        } else {
                            frequencyBand = 'high';
                        }
                        
                        const posX = x * spacing - offset;
                        const posY = y * spacing - offset;
                        const posZ = z * spacing - offset;
                        
                        const invisibleNode = new THREE.Object3D();
                        invisibleNode.position.set(posX, posY, posZ);
                        networkGroup.add(invisibleNode);
                        
                        boxes.push({
                            mesh: invisibleNode,
                            originalPosition: { x: posX, y: posY, z: posZ },
                            originalScale: 1,
                            gridPos: { x, y, z },
                            frequencyBand: frequencyBand,
                            connections: [],
                            phase: Math.random() * Math.PI * 2
                        });
                    }
                }
            }

            boxes.forEach((box, index) => {
                boxes.forEach((otherBox, otherIndex) => {
                    if (index >= otherIndex) return;
                    
                    const distance = box.mesh.position.distanceTo(otherBox.mesh.position);
                    
                    if (distance < spacing * 1.8) {
                        const lineGeometry = new THREE.BufferGeometry().setFromPoints([
                            box.mesh.position.clone(),
                            otherBox.mesh.position.clone()
                        ]);
                        
                        let lineColor = 0xffffff;
                        let lineWidth = distance < spacing * 1.2 ? 2 : 1;
                        
                        const lineMaterial = new THREE.LineBasicMaterial({ 
                            color: lineColor, 
                            transparent: true, 
                            opacity: distance < spacing * 1.2 ? 0.6 : 0.3,
                            linewidth: lineWidth
                        });
                        
                        const line = new THREE.Line(lineGeometry, lineMaterial);
                        networkGroup.add(line);
                        
                        const connection = {
                            line: line,
                            box1: box,
                            box2: otherBox,
                            originalOpacity: distance < spacing * 1.2 ? 0.6 : 0.3,
                            originalColor: lineColor,
                            distance: distance,
                            isDiagonal: distance > spacing * 1.2
                        };
                        
                        connections.push(connection);
                        box.connections.push(connection);
                        otherBox.connections.push(connection);
                    }
                });
            });

            scene.add(networkGroup);
        }

        function setupMouseControls() {
            let isDragging = false;
            
            renderer.domElement.addEventListener('mousedown', (e) => {
                isDragging = true;
            });

            renderer.domElement.addEventListener('mousemove', (e) => {
                if (isDragging) {
                    mouseX = (e.clientX / window.innerWidth) * 2 - 1;
                    mouseY = -(e.clientY / window.innerHeight) * 2 + 1;
                    targetRotationY = mouseX * Math.PI;
                    targetRotationX = mouseY * Math.PI * 0.5;
                }
            });

            renderer.domElement.addEventListener('mouseup', () => {
                isDragging = false;
            });

            renderer.domElement.addEventListener('wheel', (e) => {
                camera.position.z += e.deltaY * 0.3;
                camera.position.z = Math.max(40, Math.min(200, camera.position.z));
            });
        }

        function initAudio() {
            audioContext = new (window.AudioContext || window.webkitAudioContext)();
            analyser = audioContext.createAnalyser();
            analyser.fftSize = 1024;
            dataArray = new Uint8Array(analyser.frequencyBinCount);
        }

        function setupAudioFile(file) {
            if (audioElement) {
                audioElement.pause();
                audioElement = null;
            }
            // Disconnect and reset audioSource for new file
            if (audioSource) {
                try { audioSource.disconnect(); } catch (e) {}
                audioSource = null;
            }
            audioElement = new Audio();
            audioElement.src = URL.createObjectURL(file);
            
            // Update track info
            document.getElementById('trackTitle').textContent = file.name.replace(/\.[^/.]+$/, "");
            document.getElementById('trackSize').textContent = (file.size / 1024 / 1024).toFixed(1) + ' MB';
            document.getElementById('trackInfo').classList.remove('hidden');
            
            audioElement.addEventListener('loadedmetadata', () => {
                const duration = formatTime(audioElement.duration);
                document.getElementById('trackDuration').textContent = duration;
                document.getElementById('totalTime').textContent = duration;
                document.getElementById('progressSlider').max = audioElement.duration;
            });

            audioElement.addEventListener('timeupdate', updateProgress);
            audioElement.addEventListener('ended', () => {
                isPlaying = false;
                document.getElementById('playButton').textContent = 'PLAY';
                setProgressPlayPauseIcon(false);
            });
            
            if (audioContext && analyser) {
                audioSource = audioContext.createMediaElementSource(audioElement);
                audioSource.connect(analyser);
                analyser.connect(audioContext.destination);
            }

            // Set initial volume
            audioElement.volume = document.getElementById('volumeSlider').value / 100;

            waveformCanvas = document.getElementById('waveformCanvas');
            waveformCtx = waveformCanvas ? waveformCanvas.getContext('2d') : null;
        }

        function formatTime(seconds) {
            const mins = Math.floor(seconds / 60);
            const secs = Math.floor(seconds % 60);
            return `${mins}:${secs.toString().padStart(2, '0')}`;
        }

        function updateProgress() {
            if (audioElement && !isNaN(audioElement.duration)) {
                const progress = (audioElement.currentTime / audioElement.duration) * 100;
                document.getElementById('progressSlider').value = audioElement.currentTime;
                document.getElementById('currentTime').textContent = formatTime(audioElement.currentTime);
            }
        }

        function toggleControls() {
            const controls = document.getElementById('controls');
            const info = document.getElementById('info');
            const frequencyInfo = document.getElementById('frequencyInfo');
            const trackInfo = document.getElementById('trackInfo');
            const numbers404 = document.getElementById('numbers404');
            
            controlsVisible = !controlsVisible;
            
            if (controlsVisible) {
                controls.classList.remove('hidden');
                info.classList.remove('hidden');
                frequencyInfo.classList.remove('hidden');
                numbers404.classList.remove('hidden');
                if (audioElement) trackInfo.classList.remove('hidden');
            } else {
                controls.classList.add('hidden');
                info.classList.add('hidden');
                frequencyInfo.classList.add('hidden');
                trackInfo.classList.add('hidden');
                numbers404.classList.add('hidden');
            }
        }

        function setupEventListeners() {
            // Audio drop box
            const audioDropBox = document.getElementById('audioDropBox');
            const audioInput = document.getElementById('fileInput');
            audioDropBox.addEventListener('click', (e) => {
                if (e.target === audioDropBox) audioInput.click();
            });
            audioDropBox.addEventListener('keydown', (e) => {
                if (e.key === 'Enter' || e.key === ' ') audioInput.click();
            });
            audioDropBox.addEventListener('dragover', e => { e.preventDefault(); audioDropBox.style.background = 'rgba(255,255,255,0.15)'; });
            audioDropBox.addEventListener('dragleave', e => { e.preventDefault(); audioDropBox.style.background = 'rgba(255,255,255,0.07)'; });
            audioDropBox.addEventListener('drop', e => {
                e.preventDefault();
                audioDropBox.style.background = 'rgba(255,255,255,0.07)';
                const file = e.dataTransfer.files[0];
                if (file && file.type.startsWith('audio/')) {
                    if (!audioContext) initAudio();
                    setupAudioFile(file);
                    // Update file input display
                    const dataTransfer = new DataTransfer();
                    dataTransfer.items.add(file);
                    audioInput.files = dataTransfer.files;
                }
            });
            // Add change event for file input
            audioInput.addEventListener('change', (e) => {
                const file = e.target.files[0];
                if (file && file.type.startsWith('audio/')) {
                    if (!audioContext) initAudio();
                    setupAudioFile(file);
                }
            });
            // Video drop box
            const videoDropBox = document.getElementById('videoDropBox');
            const videoInput = document.getElementById('videoInput');
            videoDropBox.addEventListener('click', (e) => {
                if (e.target === videoDropBox) videoInput.click();
            });
            videoDropBox.addEventListener('keydown', (e) => {
                if (e.key === 'Enter' || e.key === ' ') videoInput.click();
            });
            videoDropBox.addEventListener('dragover', e => { e.preventDefault(); videoDropBox.style.background = 'rgba(255,255,255,0.15)'; });
            videoDropBox.addEventListener('dragleave', e => { e.preventDefault(); videoDropBox.style.background = 'rgba(255,255,255,0.07)'; });
            videoDropBox.addEventListener('drop', e => {
                e.preventDefault();
                videoDropBox.style.background = 'rgba(255,255,255,0.07)';
                const file = e.dataTransfer.files[0];
                if (file && (file.type.startsWith('video/') || file.type === 'image/gif')) {
                    const url = URL.createObjectURL(file);
                    if (file.type === 'image/gif') {
                        backgroundGif.src = url;
                        backgroundGif.style.display = 'block';
                        backgroundVideo.style.display = 'none';
                    } else {
                        backgroundVideo.src = url;
                        backgroundVideo.style.display = 'block';
                        backgroundVideo.currentTime = 0;
                        backgroundVideo.play();
                        backgroundGif.style.display = 'none';
                    }
                    // Update file input display
                    const dataTransfer = new DataTransfer();
                    dataTransfer.items.add(file);
                    videoInput.files = dataTransfer.files;
                }
            });
            // Add change event for video input
            videoInput.addEventListener('change', (e) => {
                const file = e.target.files[0];
                if (file && (file.type.startsWith('video/') || file.type === 'image/gif')) {
                    const url = URL.createObjectURL(file);
                    if (file.type === 'image/gif') {
                        backgroundGif.src = url;
                        backgroundGif.style.display = 'block';
                        backgroundVideo.style.display = 'none';
                    } else {
                        backgroundVideo.src = url;
                        backgroundVideo.style.display = 'block';
                        backgroundVideo.currentTime = 0;
                        backgroundVideo.play();
                        backgroundGif.style.display = 'none';
                    }
                }
            });

            // Play/Pause button
            document.getElementById('playButton').addEventListener('click', async () => {
                if (!audioElement) {
                    alert('Please select an audio file first');
                    return;
                }
                if (audioContext.state === 'suspended') {
                    await audioContext.resume();
                }
                if (isPlaying) {
                    audioElement.pause();
                    isPlaying = false;
                    document.getElementById('playButton').textContent = 'PLAY';
                    setProgressPlayPauseIcon(false);
                } else {
                    audioElement.play();
                    isPlaying = true;
                    document.getElementById('playButton').textContent = 'PAUSE';
                    setProgressPlayPauseIcon(true);
                }
            });

            // Volume control
            document.getElementById('volumeSlider').addEventListener('input', (e) => {
                if (audioElement) {
                    audioElement.volume = e.target.value / 100;
                }
                document.getElementById('volumePercent').textContent = e.target.value + '%';
            });

            // Set initial volume percent on load
            document.getElementById('volumePercent').textContent = document.getElementById('volumeSlider').value + '%';

            // Speed control
            document.getElementById('speedSlider').addEventListener('input', (e) => {
                const speed = parseFloat(e.target.value);
                document.getElementById('speedDisplay').textContent = speed.toFixed(1) + 'x';
                if (audioElement) {
                    audioElement.playbackRate = speed;
                }
            });

            // Progress seeking
            document.getElementById('progressSlider').addEventListener('input', (e) => {
                if (audioElement) {
                    audioElement.currentTime = e.target.value;
                }
            });

            // Fullscreen
            document.getElementById('fullscreenButton').addEventListener('click', () => {
                if (!document.fullscreenElement) {
                    document.documentElement.requestFullscreen().catch(err => {
                        console.log('Fullscreen not supported');
                    });
                } else {
                    document.exitFullscreen();
                }
            });

            // Keyboard controls
            document.addEventListener('keydown', (e) => {
                if (e.key.toLowerCase() === 'h') {
                    toggleControls();
                } else if (e.key.toLowerCase() === 'g' && !['INPUT', 'TEXTAREA'].includes(document.activeElement.tagName)) {
                    // Toggle grain
                    grainEnabled = !grainEnabled;
                    document.getElementById('grainToggle').checked = grainEnabled;
                    if (!grainEnabled) {
                        document.getElementById('grainOverlay').style.display = 'none';
                        grainActive = false;
                    }
                } else if (e.key === ' ') {
                    e.preventDefault();
                    document.getElementById('playButton').click();
                } else if (e.key === 'ArrowRight' && e.shiftKey) {
                    // Shift + Right Arrow: fine seek forward 1s
                    if (audioElement && !isNaN(audioElement.duration)) {
                        audioElement.currentTime = Math.min(audioElement.currentTime + 1, audioElement.duration);
                    }
                } else if (e.key === 'ArrowLeft' && e.shiftKey) {
                    // Shift + Left Arrow: fine seek backward 1s
                    if (audioElement && !isNaN(audioElement.duration)) {
                        audioElement.currentTime = Math.max(audioElement.currentTime - 1, 0);
                    }
                } else if (e.key === 'ArrowRight') {
                    // Fast forward 5 seconds
                    if (audioElement && !isNaN(audioElement.duration)) {
                        audioElement.currentTime = Math.min(audioElement.currentTime + 5, audioElement.duration);
                    }
                } else if (e.key === 'ArrowLeft') {
                    // Rewind 5 seconds
                    if (audioElement && !isNaN(audioElement.duration)) {
                        audioElement.currentTime = Math.max(audioElement.currentTime - 5, 0);
                    }
                } else if (e.key === 'ArrowUp') {
                    // Volume up
                    const slider = document.getElementById('volumeSlider');
                    let newVal = Math.min(100, parseInt(slider.value, 10) + 1);
                    slider.value = newVal;
                    if (audioElement) audioElement.volume = newVal / 100;
                    document.getElementById('volumePercent').textContent = newVal + '%';
                } else if (e.key === 'ArrowDown') {
                    // Volume down
                    const slider = document.getElementById('volumeSlider');
                    let newVal = Math.max(0, parseInt(slider.value, 10) - 1);
                    slider.value = newVal;
                    if (audioElement) audioElement.volume = newVal / 100;
                    document.getElementById('volumePercent').textContent = newVal + '%';
                }
            });

            // Drag and drop
            setupDragAndDrop();

            // Grain toggle
            document.getElementById('grainToggle').addEventListener('change', (e) => {
                grainEnabled = e.target.checked;
                if (!grainEnabled) {
                    document.getElementById('grainOverlay').style.display = 'none';
                    grainActive = false;
                }
            });

            // Window resize
            window.addEventListener('resize', () => {
                if (camera && renderer) {
                    camera.aspect = window.innerWidth / window.innerHeight;
                    camera.updateProjectionMatrix();
                    renderer.setSize(window.innerWidth, window.innerHeight);
                }
                if (grainCanvas) {
                    grainCanvas.width = window.innerWidth;
                    grainCanvas.height = window.innerHeight;
                    lastGrainResize = { w: window.innerWidth, h: window.innerHeight };
                }
            });

            // Progress play/pause
            document.getElementById('progressPlayPause').addEventListener('click', async () => {
                if (!audioElement) {
                    alert('Please select an audio file first');
                    return;
                }
                if (audioContext.state === 'suspended') {
                    await audioContext.resume();
                }
                if (isPlaying) {
                    audioElement.pause();
                    isPlaying = false;
                    document.getElementById('playButton').textContent = 'PLAY';
                    setProgressPlayPauseIcon(false);
                } else {
                    audioElement.play();
                    isPlaying = true;
                    document.getElementById('playButton').textContent = 'PAUSE';
                    setProgressPlayPauseIcon(true);
                }
            });

            // On page load, set initial icon
            setProgressPlayPauseIcon(false);
        }

        function setupDragAndDrop() {
            const dropZone = document.getElementById('dropZone');
            const container = document.body;

            ['dragenter', 'dragover', 'dragleave', 'drop'].forEach(eventName => {
                container.addEventListener(eventName, preventDefaults, false);
            });

            function preventDefaults(e) {
                e.preventDefault();
                e.stopPropagation();
            }

            ['dragenter', 'dragover'].forEach(eventName => {
                container.addEventListener(eventName, () => {
                    dropZone.classList.add('active');
                }, false);
            });

            ['dragleave', 'drop'].forEach(eventName => {
                container.addEventListener(eventName, () => {
                    dropZone.classList.remove('active');
                }, false);
            });

            container.addEventListener('drop', handleDrop, false);

            function handleDrop(e) {
                const dt = e.dataTransfer;
                const files = dt.files;
                
                if (files.length > 0) {
                    const file = files[0];
                    if (file.type.startsWith('audio/')) {
                        if (!audioContext) {
                            initAudio();
                        }
                        setupAudioFile(file);
                        // Update file input display
                        const fileInput = document.getElementById('fileInput');
                        const dataTransfer = new DataTransfer();
                        dataTransfer.items.add(file);
                        fileInput.files = dataTransfer.files;
                    }
                }
            }
        }

        function animate() {
            requestAnimationFrame(animate);

            if (!isAppStarted) return;

            currentRotationX += (targetRotationX - currentRotationX) * 0.05;
            currentRotationY += (targetRotationY - currentRotationY) * 0.05;

            // Apply rotations to network group instead of scene to keep it centered
            networkGroup.rotation.x = currentRotationX;
            networkGroup.rotation.y = currentRotationY + Date.now() * 0.0002; // Add continuous rotation

            const time = Date.now() * 0.0003;

            let bassLevel = 0;
            if (isPlaying && analyser) {
                analyser.getByteFrequencyData(dataArray);
                const bassRange = dataArray.slice(0, 20);
                bassLevel = bassRange.reduce((a, b) => a + b, 0) / bassRange.length / 255 * 1.8 * 2 * 0.6;
                const midRange = dataArray.slice(20, 80);
                const highRange = dataArray.slice(80, 160);
                const midLevel = midRange.reduce((a, b) => a + b, 0) / midRange.length / 255 * 1.5 * 0.7;
                const highLevel = highRange.reduce((a, b) => a + b, 0) / highRange.length / 255 * 1.3 * 0.7;
                const overallEnergy = (bassLevel + midLevel + highLevel) / 3;
                const pulseScale = 1 + overallEnergy * 0.54;
                networkGroup.scale.setScalar(pulseScale);
                boxes.forEach((nodeObj, index) => {
                    let amplitude, oscillation;
                    if (nodeObj.frequencyBand === 'bass') {
                        amplitude = bassLevel * 2 * 0.6;
                        oscillation = bassLevel * 14.4 * 2 * 0.6;
                    } else if (nodeObj.frequencyBand === 'mid') {
                        amplitude = midLevel;
                        oscillation = midLevel * 12.6;
                    } else {
                        amplitude = highLevel;
                        oscillation = highLevel * 16.2;
                    }
                    
                    const currentTime = Date.now() * 0.001;
                    
                    if (nodeObj.frequencyBand === 'bass') {
                        nodeObj.mesh.position.x = nodeObj.originalPosition.x + 
                            Math.sin(currentTime * 0.9 + nodeObj.phase) * oscillation;
                        nodeObj.mesh.position.y = nodeObj.originalPosition.y + 
                            Math.cos(currentTime * 0.9 + nodeObj.phase * 1.3) * oscillation;
                        nodeObj.mesh.position.z = nodeObj.originalPosition.z + 
                            Math.sin(currentTime * 0.7 + nodeObj.phase * 0.8) * oscillation * 0.7;
                    } else if (nodeObj.frequencyBand === 'mid') {
                        nodeObj.mesh.position.x = nodeObj.originalPosition.x + 
                            Math.sin(currentTime * 1.4 + nodeObj.phase) * oscillation;
                        nodeObj.mesh.position.y = nodeObj.originalPosition.y + 
                            Math.cos(currentTime * 1.4 + nodeObj.phase * 1.2) * oscillation;
                        nodeObj.mesh.position.z = nodeObj.originalPosition.z + 
                            Math.sin(currentTime * 1.1 + nodeObj.phase * 0.9) * oscillation * 0.8;
                    } else {
                        nodeObj.mesh.position.x = nodeObj.originalPosition.x + 
                            Math.sin(currentTime * 2.2 + nodeObj.phase) * oscillation;
                        nodeObj.mesh.position.y = nodeObj.originalPosition.y + 
                            Math.cos(currentTime * 2.2 + nodeObj.phase * 1.1) * oscillation;
                        nodeObj.mesh.position.z = nodeObj.originalPosition.z + 
                            Math.sin(currentTime * 2.8 + nodeObj.phase) * oscillation;
                    }
                });

                connections.forEach((connection, index) => {
                    let amplitude;
                    if (connection.box1.frequencyBand === connection.box2.frequencyBand) {
                        if (connection.box1.frequencyBand === 'bass') {
                            amplitude = bassLevel * 2 * 0.6;
                        } else if (connection.box1.frequencyBand === 'mid') {
                            amplitude = midLevel;
                        } else {
                            amplitude = highLevel;
                        }
                    } else {
                        amplitude = (bassLevel + midLevel + highLevel) / 3 * 1.5;
                    }
                    
                    const waveTime = Date.now() * 0.002;
                    const waveEffect = Math.sin(waveTime + index * 0.1) * 0.3 + 1;
                    amplitude *= waveEffect;
                    
                    amplitude *= 1.8;
                    const positions = [
                        connection.box1.mesh.position.clone(),
                        connection.box2.mesh.position.clone()
                    ];
                    
                    connection.line.geometry.dispose();
                    connection.line.geometry = new THREE.BufferGeometry().setFromPoints(positions);
                    
                    const minLineOpacity = connection.isDiagonal ? 0.1 : 0.3;
                    const maxLineOpacity = connection.isDiagonal ? 0.7 : 1.0;
                    const pulsingOpacity = minLineOpacity + (maxLineOpacity - minLineOpacity) * amplitude;
                    connection.line.material.opacity = Math.max(minLineOpacity, pulsingOpacity);
                    
                    if (amplitude > 0.3) {
                        const intensity = Math.min(1, amplitude * 1.2);
                        connection.line.material.color.setRGB(intensity, intensity, intensity);
                    } else {
                        connection.line.material.color.setRGB(0.4, 0.4, 0.4);
                    }
                });

            } else {
                const idleTime = Date.now() * 0.0005;
                
                const breathScale = 1 + Math.sin(idleTime * 0.8) * 0.05;
                networkGroup.scale.setScalar(breathScale);
                
                boxes.forEach((nodeObj, index) => {
                    let floatSpeed = 1;
                    if (nodeObj.frequencyBand === 'bass') {
                        floatSpeed = 0.7;
                    } else if (nodeObj.frequencyBand === 'high') {
                        floatSpeed = 1.3;
                    }
                    
                    const floatX = Math.sin(idleTime * floatSpeed + nodeObj.phase) * 1.2;
                    const floatY = Math.cos(idleTime * floatSpeed + nodeObj.phase * 1.1) * 1.2;
                    const floatZ = Math.sin(idleTime * floatSpeed * 0.8 + nodeObj.phase * 0.9) * 0.8;
                    
                    nodeObj.mesh.position.x = nodeObj.originalPosition.x + floatX;
                    nodeObj.mesh.position.y = nodeObj.originalPosition.y + floatY;
                    nodeObj.mesh.position.z = nodeObj.originalPosition.z + floatZ;
                });

                connections.forEach((connection, index) => {
                    const positions = [
                        connection.box1.mesh.position.clone(),
                        connection.box2.mesh.position.clone()
                    ];
                    
                    connection.line.geometry.dispose();
                    connection.line.geometry = new THREE.BufferGeometry().setFromPoints(positions);
                    
                    const pulseOpacity = connection.originalOpacity * 0.7 + 
                        Math.sin(idleTime * 1.5 + index * 0.2) * 0.2;
                    connection.line.material.opacity = Math.max(0.1, pulseOpacity);
                    connection.line.material.color.setRGB(0.5, 0.5, 0.5);
                });
            }

            // Grain logic
            if (grainEnabled && bassLevel > 0.6 && isPlaying) {
                document.getElementById('grainOverlay').style.display = 'block';
                grainActive = true;
                animateGrain(bassLevel);
            } else {
                document.getElementById('grainOverlay').style.display = 'none';
                grainActive = false;
            }

            drawWaveformAndTimestamp();
            renderer.render(scene, camera);
        }

        function createGrainOverlay() {
            const grainOverlay = document.getElementById('grainOverlay');
            grainOverlay.innerHTML = '';
            grainCanvas = document.createElement('canvas');
            grainCanvas.style.position = 'absolute';
            grainCanvas.style.top = '0';
            grainCanvas.style.left = '0';
            grainCanvas.style.width = '100vw';
            grainCanvas.style.height = '100vh';
            grainCanvas.width = window.innerWidth;
            grainCanvas.height = window.innerHeight;
            grainOverlay.appendChild(grainCanvas);
            grainOverlay.style.position = 'fixed';
            grainOverlay.style.top = '0';
            grainOverlay.style.left = '0';
            grainOverlay.style.width = '100vw';
            grainOverlay.style.height = '100vh';
            grainOverlay.style.pointerEvents = 'none';
            grainOverlay.style.zIndex = '2';
            grainOverlay.style.display = 'none';
            grainCtx = grainCanvas.getContext('2d');
            lastGrainResize = { w: window.innerWidth, h: window.innerHeight };
        }

        function animateGrain(bassLevel = 0) {
            if (!grainActive || !grainEnabled) return;
            if (!grainCanvas || !grainCtx) return;
            // Resize if needed
            if (lastGrainResize.w !== window.innerWidth || lastGrainResize.h !== window.innerHeight) {
                grainCanvas.width = window.innerWidth;
                grainCanvas.height = window.innerHeight;
                lastGrainResize = { w: window.innerWidth, h: window.innerHeight };
            }
            const w = grainCanvas.width;
            const h = grainCanvas.height;
            const imageData = grainCtx.createImageData(w, h);
            // Make grain more visible as bass increases
            const baseAlpha = 16;
            const maxAlpha = 90;
            const alpha = baseAlpha + Math.min(1, bassLevel) * (maxAlpha - baseAlpha);
            const baseV = 210;
            const maxV = 255;
            const vRange = maxV - baseV;
            for (let i = 0; i < imageData.data.length; i += 4) {
                // Higher bass = higher contrast and brightness
                const v = baseV + Math.random() * vRange * Math.min(1, bassLevel);
                imageData.data[i] = v;
                imageData.data[i + 1] = v;
                imageData.data[i + 2] = v;
                imageData.data[i + 3] = Math.random() * alpha + alpha * 0.5;
            }
            grainCtx.putImageData(imageData, 0, 0);
        }

        function setProgressPlayPauseIcon(isPlaying) {
            const iconSpan = document.getElementById('progressPlayPauseIcon');
            if (isPlaying) {
                // Pause icon
                iconSpan.innerHTML = `<svg width='16' height='16' viewBox='0 0 16 16' fill='currentColor' xmlns='http://www.w3.org/2000/svg'><rect x='3' y='2' width='3' height='12'/><rect x='10' y='2' width='3' height='12'/></svg>`;
            } else {
                // Play icon
                iconSpan.innerHTML = `<svg width='16' height='16' viewBox='0 0 16 16' fill='currentColor' xmlns='http://www.w3.org/2000/svg'><polygon points='4,2 13,8 4,14'/></svg>`;
            }
        }

        function drawWaveformAndTimestamp() {
            if (!waveformCanvas || !waveformCtx || !analyser) return;
            let bufferLength = analyser.fftSize;
            let dataArray = new Uint8Array(bufferLength);
            analyser.getByteTimeDomainData(dataArray);
            waveformCtx.clearRect(0, 0, waveformCanvas.width, waveformCanvas.height);
            // Draw bars as rounded rectangles
            const barCount = 64;
            const step = Math.floor(bufferLength / barCount);
            const barWidth = waveformCanvas.width / barCount * 0.7;
            const gap = waveformCanvas.width / barCount * 0.3;
            // Compute smoothed bar heights using a moving average
            let heights = [];
            for (let i = 0; i < barCount; i++) {
                let v = dataArray[i * step] / 255.0;
                heights.push(v);
            }
            // Apply moving average smoothing (window size 3)
            let smoothed = [];
            for (let i = 0; i < heights.length; i++) {
                let sum = 0;
                let count = 0;
                for (let j = -1; j <= 1; j++) {
                    if (heights[i + j] !== undefined) {
                        sum += heights[i + j];
                        count++;
                    }
                }
                smoothed.push(sum / count);
            }
            for (let i = 0; i < barCount; i++) {
                let barHeight = smoothed[i] * waveformCanvas.height * 0.76; // 20% less reactive
                let x = i * (barWidth + gap);
                let y = waveformCanvas.height - barHeight;
                waveformCtx.beginPath();
                const radius = Math.min(barWidth, barHeight) * 0.45;
                // Draw rounded rectangle
                waveformCtx.moveTo(x + radius, y);
                waveformCtx.lineTo(x + barWidth - radius, y);
                waveformCtx.quadraticCurveTo(x + barWidth, y, x + barWidth, y + radius);
                waveformCtx.lineTo(x + barWidth, y + barHeight - radius);
                waveformCtx.quadraticCurveTo(x + barWidth, y + barHeight, x + barWidth - radius, y + barHeight);
                waveformCtx.lineTo(x + radius, y + barHeight);
                waveformCtx.quadraticCurveTo(x, y + barHeight, x, y + barHeight - radius);
                waveformCtx.lineTo(x, y + radius);
                waveformCtx.quadraticCurveTo(x, y, x + radius, y);
                waveformCtx.closePath();
                waveformCtx.fillStyle = 'rgba(255,255,255,0.72)';
                waveformCtx.shadowColor = 'rgba(255,255,255,0.35)';
                waveformCtx.shadowBlur = 6;
                waveformCtx.fill();
                waveformCtx.shadowBlur = 0;
            }
            // Live timestamp
            if (audioElement) {
                document.getElementById('liveTimestamp').textContent = formatTime(audioElement.currentTime);
            }
        }
    </script>
</body>
</html>